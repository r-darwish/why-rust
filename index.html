<!doctype html>
<html>
  <head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>Why Rust</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/solarized.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/solarized-light.css">

	<!-- Printing and PDF exports -->
	<script>
	  var link = document.createElement( 'link' );
	  link.rel = 'stylesheet';
	  link.type = 'text/css';
	  link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
	  document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>
  </head>
  <body>
	<div class="reveal">
	  <div class="slides">
		<section>
          <h1>Why Rust</h1>
          <aside class="notes">
            The purpose of this presentation
          </aside>
        </section>
        <section>
          <h2>What is Rust?</h2>
          <aside class="notes">
            <ul>
              <li>Programming language made by Mozilla</li>
              <li>Compiles to native assembly like C++</li>
              <li>Performance similar to C++</li>
              <li>Procedural language</li>
            </ul>
          </aside>
        </section>
        <section>
          <img src="example.png"/>
          <aside class="notes">
            If it look like C++, why should we invest time in it?
          </aside>
        </section>
        <section>
          <section>
            <h3>Rust is type safe</h3>

            Python
            <pre>
              <code data-trim class="python">
def f2c(fahreheit):
    return (fahreheit - 32) / 5 * 9
              </code>
            </pre>

            Rust
            <pre>
              <code data-trim class="Rust">
fn f2c(fahrenheit: f64) -> f64 {
    (fahrenheit - 32.0) * 5.0 / 9.0
}
              </code>
            </pre>
          </section>

          <section>
            <h3>Rust is really type safe</h3>

            C
            <pre>
              <code data-trim class="C">
ssize_t write(int fd, const void *buf, size_t count);
              </code>
            </pre>

            Rust
            <pre>
              <code data-trim class="Rust">
fn write(&mut self, buf: &[u8]) -> Result&lt;usize&gt;
              </code>
            </pre>

            <aside class="notes">
              <ul>
                <li>Error value is magic in the return code</li>
                <li>Buffer is void pointer</li>
                <li>fd is int</li>
              </ul>
            </aside>
          </section>

          <section>
            <h3>Rust is really really type safe</h3>

            Java
            <pre>
              <code data-trim class="Java">
public static Path createFile(Path path,
                              FileAttribute&lt;?&gt;... attrs)
                       throws IOException
              </code>
            </pre>

            Rust
            <pre>
              <code data-trim class="Rust">
pub fn create&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;File&gt;
              </code>
            </pre>

            <aside class="notes">
              You cannot specify a null path in Rust
            </aside>
          </section>

          <section>
            <h3>Rust is really really type safe</h3>

            <ul>
              <li>No magical values like -1</li>
              <li>No null value</li>
              <li>Enums aren't integers</li>
              <li>No use of primitives for OS resources (Handle / File Descriptor)</li>
            </ul>
          </section>

          <section>
            If you want to go even further beoynd

            <pre>
              <code data-trim class="rust">
#[macro_use]
extern crate derive_more;

#[derive(Add, Sub, Copy, Clone)]
struct Years(i64);

#[derive(Add, Sub, Copy, Clone)]
struct Days(i64);

fn main() {
    let age = Years(5);
    let uptime = Days(1);

    uptime + uptime; // Ok
    uptime + age; // Compilation Error
    uptime / uptime; // Compilation Error
}

              </code>
            </pre>

            <small>How do you say "◊î◊í◊ì◊ú◊™ ◊®◊ê◊©" in English? ü§î</small>
          </section>

          <section>
            But what if something needs to be nullable

            <pre>
              <code data-trim class="rust">
fn welcome(name: Option&lt;&amp;str&gt;) {
    let name = match name {
        Some(name) =&gt; name,
        None =&gt; &quot;John Doe&quot;
    };

    println!(&quot;Welcome {}&quot;, name)

}

fn better_welcome(name: Option&lt;&amp;str&gt;) {
    println!(&quot;Welcome {}&quot;, name.unwrap_or(&quot;John Doe&quot;))

}

fn main() {
    welcome(Some(&quot;Darwish&quot;));
    welcome(None)
}
              </code>
            </pre>
          </section>

          <section>
            As I said, no magic values

            <pre>
              <code data-trim class="rust">
pub fn find&lt;&#x27;a, P&gt;(&amp;&#x27;a self, pat: P) -&gt; Option&lt;usize&gt;

pub fn create&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;File&gt;
              </code>
            </pre>

            <aside class="notes">
              <ul>
                <li>Note that usize is unsigned</li>
                <li>No modern language uses magic for files, but every language I checked use -1 for string finding.</li>
              </ul>
            </aside>

          </section>

          <section>
            Result isn't a tuple like in Go

            <pre>
              <code data-trim class="go">
file, err := os.Open("file.go") // For read access.
if err != nil {
	log.Fatal(err)

    // Oops I forgot to return üò≠
}

data := make([]byte, 100)
count, err := file.Read(data)
              </code>
            </pre>

            <pre>
              <code data-trim class="Rust">
let mut f = fs::File::create("name")?;
f.write_all(b"Hello")?;
println!("File written üëè");
              </code>
            </pre>

            <aside class="notes">
              The code will not compile if I forget the first question mark.
            </aside>
          </section>

          <section>
            But what if I forget the second question mark?

            <pre>
              <code data-trim class="Rust">
let mut f = fs::File::create("name")?;
f.write_all(b"Hello");
println!("File written üëè");
              </code>
            </pre>

            <pre class="fragment">
              <code data-trim class="nohighlight">
warning: unused `std::result::Result` that must be used
 --> src/main.rs:6:5
  |
6 |     f.write_all(b"Hello");
  |     ^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(unused_must_use)] on by default
  = note: this `Result` may be an `Err` variant, which should be handled
              </code>
            </pre>

            <aside class="notes">
              You can't forget about error handling and you know what can fail
            </aside>
          </section>
        </section>

        <section>
          <section>
            Not just a language, but an entire toolchain
            <table>
              <thead>
                <tr>
                  <th>Tool</th>
                  <th>C++</th>
                  <th>Python</th>
                  <th>Rust</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>compiler</td>
                  <td>Clang, MSVC, GCC</td>
                  <td>CPython, PyPy, Jython</td>
                  <td>rustc, gcc-rust</td>
                </tr>
                <tr>
                  <td>Package Manager</td>
                  <td>Conan, Hunter, vcpkg</td>
                  <td>pip, setuptools</td>
                  <td>Cargo</td>
                </tr>
                <tr>
                  <td>Build system</td>
                  <td>Automake, CMake, Scons, VS</td>
                  <td>setuptools, pbr, poetry, buildout</td>
                  <td>Cargo</td>
                </tr>
              </tbody>
            </table>

            <aside class="notes">
              <ul>
                <li>pip is a disaster</li>
                <li>Conan is the best we found for C++, but life is tough</li>
                <li>Every build system for C++ is a different language</li>
              </ul>
            </aside>
          </section>

          <section>
            Not just a language, but an entire toolchain
            <table>
              <thead>
                <tr>
                  <th>Tool</th>
                  <th>C++</th>
                  <th>Python</th>
                  <th>Rust</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Code formatter</td>
                  <td>--</td>
                  <td>Black, isort</td>
                  <td>rustfmt</td>
                </tr>
                <tr>
                  <td>Linter</td>
                  <td>clang-tidy</td>
                  <td>flake8, pylint, pyflakes, mypy</td>
                  <td>Clippy</td>
                </tr>
                <tr>
                  <td>Testing</td>
                  <td>Catch, gtest</td>
                  <td>pytest, slash</td>
                  <td>built in</td>
                </tr>
              </tbody>

              <aside class="notes">
                <ul>
                  <li>You have to make black not fight with isort if you want both</li>
                  <li>UT can access private members</li>
                </ul>
              </aside>
            </table>
          </section>
        </section>

        <section>
          <h2>OS Support</h2>
          Windows, Linux and macOS are all tier 1<br/><br/>

          Yes, all the toolchain works in Windows
        </section>

        <section>
          <h2>Batteries included</h2>
          And they aren't corroded!

          <aside class="notes">
            <ul>
              <li>Python's built in library is full of deprecated modules</li>
              <li>Rust focuses on the toolchain and have a small standard library</li>
              <li>C's standard library is a mess</li>
              <li>C++ standard library is a bit better but only recently started handling files</li>
              <li>Rust took better 3rd party implementations of the Mutex and the hash table</li>
            </ul>
          </aside>
        </section>

        <section>
          <section data-transition="fade-out">
            <h2>Threads are awesome</h2>

            <pre>
              <code data-trim class="python">
import threading

_COUNTER = 0

def thread_function():
    global _COUNTER

    RAX = _COUNTER
    RAX = RAX + 1
    _COUNTER = RAX


if __name__ == "__main__":

    threads = [threading.Thread(target=thread_function)
               for _ in range(100)]

    for t in threads:
        t.start()

    for t in threads:
        t.join()

    print()
    print(_COUNTER)
              </code>
            </pre>

            <aside class="notes">
              This works by accident and doesn't run in parallel
            </aside>
          </section>

          <section data-transition="fade-in fade-out">
            <h2>Threads awesome are</h2>

            <pre>
              <code data-trim class="python">
import threading

_COUNTER = 0

def thread_function():
    global _COUNTER

    print(".", end="", flush=True)
    RAX = _COUNTER
    print(".", end="", flush=True)
    RAX = RAX + 1
    print(".", end="", flush=True)
    _COUNTER = RAX


if __name__ == "__main__":

    threads = [threading.Thread(target=thread_function)
               for _ in range(100)]

    for t in threads:
        t.start()

    for t in threads:
        t.join()

    print()
    print(_COUNTER)
              </code>
            </pre>
          </section>

          <section data-transition="fade-in fade-out">
            <h2>TÃïÃ®hÕèrÕû“âeÕúÃ°aÕ°dÕ¢sÃ∂ Ã¥Õ°aÃïÕèÃ¢wÕ†eÕ†sÕèoÃ¥mÕüÃµeÕ°Ãï Ã∏ÕèaÕúr“âÕòÕûeÕûÃï</h2>

            <pre>
              <code data-trim class="python">
import threading

_COUNTER = 0
_LOCK = threading.Lock()

def thread_function():
    global _COUNTER

    with _LOCK:
        print(".", end="", flush=True)
        RAX = _COUNTER
    print(".", end="", flush=True)
    RAX = RAX + 1
    print(".", end="", flush=True)
    _COUNTER = RAX

              </code>
            </pre>

            <aside class="notes">
              This works by accident and doesn't run in parallel
            </aside>
          </section>

          <section>
            <h2>You shall not pass!</h2>

            <pre>
              <code data-trim class="rust">
let mut threads = vec![];
let mut counter = 0;

for _ in 0..NTHREADS {
    threads.push(thread::spawn(|| {
        counter += 1;
    }));
}
              </code>
            </pre>
          </section>

          <section>
            <h2>You shall not pass!</h2>

            <pre>
              <code data-trim class="nohighlight">
error[E0499]: cannot borrow `counter` as mutable more than once at a time
  --> src/main.rs:12:36
   |
12 |           threads.push(thread::spawn(|| {
   |                        -             ^^ mutable borrow starts here in previous iteration of loop
   |  ______________________|
   | |
13 | |             counter += 1;
   | |             ------- borrows occur due to use of `counter` in closure
14 | |         }));
   | |__________- argument requires that `counter` is borrowed for `'static`
              </code>
            </pre>
          </section>

          <section>
            Rust has atomic types
            <pre>
              <code data-trim class="rust">
let mut threads = vec![];
let counter = Arc::new(AtomicU32::new(0));

for _ in 0..NTHREADS {
    let counter = counter.clone();
    threads.push(thread::spawn(move || {
        counter.fetch_add(1, Ordering::SeqCst);
    }));
}
              </code>
            </pre>
          </section>

          <section>
            And a mutex
            <pre>
              <code data-trim class="rust">
let mut threads = vec![];
let message_mutex = Arc::new(Mutex::new(String::from("It's over 9000")));

for _ in 0..NTHREADS {
    let message_mutex = message_mutex.clone();
    threads.push(thread::spawn(move || {
        let mut message = message_mutex.lock().unwrap();
        message.push('!');
    }));
}
              </code>
            </pre>
          </section>


        </section>
	  </div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
	  // More info about config & dependencies:
	  // - https://github.com/hakimel/reveal.js#configuration
	  // - https://github.com/hakimel/reveal.js#dependencies
	  Reveal.initialize({
		dependencies: [
		  { src: 'plugin/markdown/marked.js' },
		  { src: 'plugin/markdown/markdown.js' },
		  { src: 'plugin/notes/notes.js', async: true },
		  { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
		]
	  });
	</script>
  </body>
</html>
